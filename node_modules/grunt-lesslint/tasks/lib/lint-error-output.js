(function() {
  var LintErrorOutput, SourceMapConsumer, chalk, stripPath, _;

  SourceMapConsumer = require('source-map').SourceMapConsumer;

  _ = require('underscore');

  chalk = require('chalk');

  stripPath = require('strip-path');

  LintErrorOutput = (function() {
    function LintErrorOutput(result, grunt) {
      this.result = result;
      this.grunt = grunt;
    }

    LintErrorOutput.prototype.display = function(importsToLint) {
      var column, errorCount, file, fileContents, fileLines, filePath, fullRuleMessage, isThisFile, less, lessSource, line, message, messageGroups, messages, rule, ruleMessage, ruleMessages, source, sourceMap, _i, _len, _ref;
      sourceMap = new SourceMapConsumer(this.result.sourceMap);
      errorCount = 0;
      messages = this.result.lint.messages;
      less = this.result.less;
      file = this.result.file;
      fileContents = {};
      fileLines = {};
      messages = messages.filter((function(_this) {
        return function(message) {
          var isThisFile, source;
          source = sourceMap.originalPositionFor({
            line: message.line,
            column: message.col
          }).source;
          isThisFile = source === file;
          return isThisFile || _this.grunt.file.isMatch(importsToLint, source);
        };
      })(this));
      if (messages.length < 1) {
        return 0;
      }
      messageGroups = _.groupBy(messages, function(_arg) {
        var message;
        message = _arg.message;
        return message;
      });
      this.grunt.log.writeln("" + (chalk.yellow(file)) + " (" + messages.length + ")");
      for (ruleMessage in messageGroups) {
        ruleMessages = messageGroups[ruleMessage];
        rule = ruleMessages[0].rule;
        fullRuleMessage = "" + ruleMessage + " ";
        if (rule.desc && rule.desc !== ruleMessage) {
          fullRuleMessage += "" + rule.desc + " ";
        }
        this.grunt.log.writeln(fullRuleMessage + chalk.grey("(" + rule.id + ")"));
        for (_i = 0, _len = ruleMessages.length; _i < _len; _i++) {
          message = ruleMessages[_i];
          errorCount += 1;
          _ref = sourceMap.originalPositionFor({
            line: message.line,
            column: message.col
          }), line = _ref.line, column = _ref.column, source = _ref.source;
          isThisFile = source === file;
          message.lessLine = {
            line: line,
            column: column
          };
          if (!fileContents[source]) {
            if (isThisFile) {
              fileContents[source] = less;
            } else {
              fileContents[source] = this.grunt.file.read(source);
            }
            fileLines[source] = fileContents[source].split('\n');
          }
          filePath = stripPath(file, process.cwd());
          lessSource = fileLines[source][line - 1].slice(column);
          this.grunt.log.error(chalk.gray("[Line " + line + ", Column " + (column + 1) + "]:\t") + (" " + (lessSource.trim())));
        }
      }
      return errorCount;
    };

    return LintErrorOutput;

  })();

  module.exports = LintErrorOutput;

}).call(this);
